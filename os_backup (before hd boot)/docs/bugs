VVV	实现硬盘驱动时,在进程恢复状态时没有关中断,导致进程表倍破坏	4/20	22:19
又出bug了, 实现键盘识别系统调用时,有几率报异常,或者虚拟机崩溃.
后来发现原因是:在a进程写完硬盘的command寄存器之后,硬盘中断马上就来了,而这时a进程可能正在进行block的写进程表(保存环境),或者已经保存完a进程正在恢复b进程的环境,这两种情况没有关中断,导致进程环境保存或进程恢复过程中,进程表被破坏.解决办法是,直到iretd之前都要关中断.
下次记住,在进程从进程表恢复状态和从写进程表保存状态的时候一定要关中断,不然进程表被破坏,哭都没地方哭...
======================================================================================================================================================
XXX	装饰建装饰错误问题	4/19

就是如果readcombokey太慢的话(比如后面加个millidelay（1000）)  后面按得装饰件会装饰到当前队列刚刚读出的普通键上
======================================================================================================================================================
VVV	未解之谜	4/19 20:40

为了增加通用性在proc_running_restart中加了一句mov	esp, [p_proc_running],会造成奇奇怪怪的问题(键盘中断出错...)
解决办法就是把他注释掉...
下面是代码:

restart:					;若不是重入中断则切换进程
	mov	esp, [p_proc_ready]		;p_proc_ready在global.h声明,存放就绪进程的进程表地址,这条语句将esp转到就绪进程的进程表
	mov	[p_proc_running], esp		;接下来就绪进程将要运行,所以现在运行进程指针p_proc_running指向就绪进程
	lldt	[esp + P_LDT_SEL]		;载入进程表中的ldt选择子
	lea	eax, [esp + P_STACKTOP]		
	mov	dword [tss + TSS3_S_SP0], eax	;将tts中的sp0设置为就绪进程进程表的最高地址,下次进程进入内核态的时候esp就会指向这个进程表

restart_reenter:				;若是重入终端则不切换进程
	dec	dword [k_reenter]
proc_running_restart:
;	mov	esp, [p_proc_running]
	pop	gs	;'.
	pop	fs	; |
	pop	es	; |恢复寄存器值
	pop	ds	; |
	popad		;/

	add	esp, 4	;跳过指向retstart或restart_reenter的指针

	iretd				;跳转到指定进程
======================================================================================================================================================
VVV	block和ublock实现	4/18

1.block的时候写a进程表没有问题
2.但是unblock的时候如果马上切换进程那么会出现两次iret,
	第一次是切换进程时进行的iret,切换成功,恢复进程a,a回到sysunblock,然后依次返回...,
	回到sys_call,又一次回复进程状态(这已经不是原来进入syscall时候保存的进程表了,而是我们在立即切换的时候保存的进程表),然后第二次iret,由于进程表已经被修改过了,我们又回到了sysunblock...
	之后就循环了...

======================================================================================================================================================
