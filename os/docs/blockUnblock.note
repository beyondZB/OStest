宏内核不像微内核,系统调用全靠消息传递的方式来实现
在宏内核下实现硬盘驱动,就是把操作键盘动作,做成一个个系统调用.
要实现硬盘驱动必须要在发送命令之后,等待硬盘中断响应,才能继续处理.我们现在的宏内核中没有像微内核的消息机制,所以要编写void kernelB
lock()和void kernelUnblock(u32 pid)两个,来在等待中断的时候阻塞进程,在中断来临的时候让进程恢复运行.

在编写这两个函数的时候遇到了很大的麻烦,下面是实现这两个函数的技术细节
一.这两个函数要做什么比较清晰:
	block:  改变当前进程状态为阻塞	调度切换进程
	unblock:改变进程号为pid的进程的状态为就绪	调度切换进程

二.由于是内核函数,所以不能直接通过进程调用,所以增加了两个系统调用void block(), void unnblock(u32 pid).
	在a进程中调用一次block 在b进程中调用一次unblock

三.由于当前的调度,属于单纯的时间片轮转,而且PCB中并没有反应当前进程状态的字段以供时钟中断中的调度函数使用,所以在PCB(也就是代码中的PROCESS结构)中增加了u8 state这一字段,并定义下面三个值
#define PROC_STATE_RUNNING	0
#define PROC_STATE_READY	1
#define PROC_STATE_BLOCKING	2
来反应当前进程状态

四.由于要在改变状态后立即切换进程,所以一开始我想到了,在中断处理函数中的save(保存当前环境,即写进程表,若为非重入中断则进入内核栈)和restart(将esp指向就绪进程表,并弹栈恢复进程环境)这两个函数.但是实现之后会报异常,调试后发现:
	1.我们的进程并不是通过中断进入save的,并没有吧esp指向进程表(若通过中断进入save,那么esp会指向之前在tss中设置好的进程表最高地址处),所以没有写好进程表
	2.系统调用不会发生重入,因为,当前进程在进入系统调用之后,不会再次使用系统调用,所以不应该处理k_reenter(当k_reenter==0时代表非重入中断),否则会造成,硬件中断处理的时候判断是否重入异常,导致破坏PCB.

五.由于四的原因,要单独写了kernelshift来处理进程切换,这次进程表写对了,切换也没有什么问题,但是当b进程unblock a进程的时候发生了问题.调试后发现:
	1.现在的内核栈情况是,所有进程的系统调用和硬件中断公用一个内核栈,这回导致内核栈混乱,比如一个进程调用了系统调用,在内核栈,中压了一些数据,这时始终中断来了,切换到另外一个进程,又调用了系统调用,由于使用同一个内核栈,这个进程使用内核栈时会破坏之前进程在内核栈中保存的数据.

六.根据五发现的问题,我们将硬件中断和系统调用分开处理(原先都是调用save;call fun;restart),硬件中断使用公用的内核栈,每个进程有自己单独的进程内核栈来处理自己的系统调用;硬件中断处理重入,系统调用不处理重入.但是,这时又发现了问题:
	1.在进入系统调用block之后,我们写了一次进程表来保存环境,在调用kernelShift的时候又写了一次进程表,保存环境,结果就是进入系统调用时的环境丢失了,造成的结果是在b进程调用unblock系统调用的时候,kernelshift切换进程,会出现两次iret,
	第一次是切换进程时进行的iret,切换成功,恢复进程a,a回到kernelblock,然后依次返回...,
	回到sys_call,又一次回复进程状态(这已经不是原来进入syscall时候保存的进程表了,而是我们在立即切换的时候保存的进程表),这就是二次iret,由于进程表已经被修改过了(进入),我们又回到了kernelblock...之后就进入了死循环...

七.根据六发现的问题,为每个进程增加一个系统调用状态备份表,用于专门存储系统调用时的环境,在保存环境的时候先写进程表,再把进程表复制一份到系统调用状态备份表中,在恢复环境的时候,我们会从系统状态备份表复制内容到进程表,然后再恢复状态返回.

终于block和unblock的系统调用能正常使用了!!
