宏内核不像微内核,系统调用全靠消息传递的方式来实现			章博	2015/4/19
在宏内核下实现硬盘驱动,就是把操作键盘动作,做成一个个系统调用.
要实现硬盘驱动必须要在发送命令之后,等待硬盘中断响应,才能继续处理.我们现在的宏内核中没有像微内核的消息机制,所以要编写void kernelB
lock()和void kernelUnblock(u32 pid)两个,来在等待中断的时候阻塞进程,在中断来临的时候让进程恢复运行.

在编写这两个函数的时候遇到了很大的麻烦,下面是实现这两个函数的技术细节
一.这两个函数要做什么比较清晰:
	block:  改变当前进程状态为阻塞	调度切换进程
	unblock:改变进程号为pid的进程的状态为就绪	调度切换进程

二.由于是内核函数,所以不能直接通过进程调用,所以增加了两个系统调用void block(), void unnblock(u32 pid).
	在a进程中调用一次block 在b进程中调用一次unblock

三.由于当前的调度,属于单纯的时间片轮转,而且PCB中并没有反应当前进程状态的字段以供时钟中断中的调度函数使用,所以在PCB(也就是代码中的PROCESS结构)中增加了u8 state这一字段,并定义下面三个值
#define PROC_STATE_RUNNING	0
#define PROC_STATE_READY	1
#define PROC_STATE_BLOCKING	2
来反应当前进程状态

四.由于要在改变状态后立即切换进程,所以一开始我想到了,在中断处理函数中的save(保存当前环境,即写进程表,若为非重入中断则进入内核栈)和restart(将esp指向就绪进程表,并弹栈恢复进程环境)这两个函数.但是实现之后会报异常,调试后发现:
	1.我们的进程并不是通过中断进入save的,并没有吧esp指向进程表(若通过中断进入save,那么esp会指向之前在tss中设置好的进程表最高地址处),所以没有写好进程表
	2.系统调用不会发生重入,因为,当前进程在进入系统调用之后,不会再次使用系统调用,所以不应该处理k_reenter(当k_reenter==0时代表非重入中断),否则会造成,硬件中断处理的时候判断是否重入异常,导致破坏PCB.

五.由于四的原因,要单独写了kernelshift来处理进程切换,这次进程表写对了,切换也没有什么问题,但是当b进程unblock a进程的时候发生了问题.调试后发现:
	1.现在的内核栈情况是,所有进程的系统调用和硬件中断公用一个内核栈,这回导致内核栈混乱,比如一个进程调用了系统调用,在内核栈,中压了一些数据,这时始终中断来了,切换到另外一个进程,又调用了系统调用,由于使用同一个内核栈,这个进程使用内核栈时会破坏之前进程在内核栈中保存的数据.

六.根据五发现的问题,我们将硬件中断和系统调用分开处理(原先都是调用save;call fun;restart),硬件中断使用公用的内核栈,每个进程有自己单独的进程内核栈来处理自己的系统调用;硬件中断处理重入,系统调用不处理重入.但是,这时又发现了问题:
	1.在进入系统调用block之后,我们写了一次进程表来保存环境,在调用kernelShift的时候又写了一次进程表,保存环境,结果就是进入系统调用时的环境丢失了,造成的结果是在b进程调用unblock系统调用的时候,kernelshift切换进程,会出现两次iret,
	第一次是切换进程时进行的iret,切换成功,恢复进程a,a回到kernelblock,然后依次返回...,
	回到sys_call,又一次回复进程状态(这已经不是原来进入syscall时候保存的进程表了,而是我们在立即切换的时候保存的进程表),这就是二次iret,由于进程表已经被修改过了(进入),我们又回到了kernelblock...之后就进入了死循环...

七.根据六发现的问题,发现在进入系统调用时需要保存状态,在系统调用内进行切换也需要保存状态,即一个进程要在系统调用中完成切换,需要保存两份状态.所以为每个进程增加一个系统调用状态备份表,用于专门存储系统调用时的环境,在保存环境的时候先写进程表,再把进程表复制一份到系统调用状态备份表中,在恢复环境的时候,我们会从系统状态备份表复制内容到进程表,然后再恢复状态返回.由于系统状态备份表的存在,我们就可以在系统调用内进行进程切换时毫无顾虑地使用进程表了来保存状态了.

终于block和unblock的系统调用能正常使用了!!


================================================================================================================================================
15/4/20	22:20
又出bug了, 实现键盘识别系统调用时,有几率报异常,或者虚拟机崩溃.
后来发现原因是:在a进程写完硬盘的command寄存器之后,硬盘中断马上就来了,而这时a进程可能正在进行block的写进程表(保存环境),或者已经保存完a进程正在恢复b进程的环境,这两种情况没有关中断,导致进程环境保存或进程恢复过程中,进程表被破坏.解决办法是,直到iretd之前都要关中断.
下次记住,在进程从进程表恢复状态和从写进程表保存状态的时候一定要关中断,不然进程表被破坏,哭都没地方哭...
